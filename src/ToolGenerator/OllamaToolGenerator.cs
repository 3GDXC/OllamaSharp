using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace OllamaSharp;

[Generator]
public class OllamaToolGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context)
	{
		// Registriert unseren SyntaxReceiver, der SyntaxNodes mit [OllamaTool] sucht
		context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());

#if DEBUG
		if (!System.Diagnostics.Debugger.IsAttached)
		{
			//System.Diagnostics.Debugger.Launch();
		}
#endif
	}

	public void Execute(GeneratorExecutionContext context)
	{
		// Prüfen, ob wir unseren SyntaxReceiver haben
		if (context.SyntaxReceiver is not SyntaxReceiver receiver)
			return;

		// Wir holen uns das Compilation-Objekt, um später Symbole abzufragen
		var compilation = context.Compilation;

		// StringBuilder für das generierte JSON
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated />");
		sb.AppendLine("namespace MyOllamaTools");
		sb.AppendLine("{");
		sb.AppendLine("    public static class GeneratedOllamaTools");
		sb.AppendLine("    {");
		sb.AppendLine("        public static string ToolsJson => \"\"\"");
		sb.AppendLine("[");

		bool firstMethod = true;

		// Wir durchlaufen alle gefundene Methoden-Syntaxknoten
		foreach (var methodDecl in receiver.CandidateMethods)
		{
			// Aus dem Syntaxknoten das Symbol abfragen
			var model = compilation.GetSemanticModel(methodDecl.SyntaxTree);
			var symbol = model.GetDeclaredSymbol(methodDecl) as IMethodSymbol;
			if (symbol == null)
				continue;

			// Name der Methode
			string methodName = symbol.Name;

			// Summary aus den DocComments
			string methodSummary = GetSummaryFromDocs(symbol.GetDocumentationCommentXml());
			string description = EscapeForJson(methodSummary);

			// Parameter-Teil im JSON bauen
			var parametersJson = BuildParametersJson(symbol);

			// Komma-Logik zwischen den JSON-Objekten
			if (!firstMethod)
			{
				sb.AppendLine(",");
			}
			firstMethod = false;

			// JSON-Ausgabe
			sb.AppendLine("  {");
			sb.AppendLine("    \"type\": \"function\",");
			sb.AppendLine("    \"function\": {");
			sb.AppendLine($"      \"name\": \"{methodName}\",");
			sb.AppendLine($"      \"description\": \"{description}\",");
			sb.AppendLine("      \"parameters\": {");
			sb.AppendLine("        \"type\": \"object\",");
			sb.AppendLine($"        \"properties\": {{ {parametersJson} }},");
			var requiredParamNames = string.Join(", ", symbol.Parameters.Select(p => $"\"{p.Name}\""));
			sb.AppendLine($"        \"required\": [{requiredParamNames}]");
			sb.AppendLine("      }");
			sb.AppendLine("    }");
			sb.Append("  }");
		}

		sb.AppendLine();
		sb.AppendLine("]");
		sb.AppendLine("\"\"\";");
		sb.AppendLine("    }");
		sb.AppendLine("}");

		// Den generierten Code als neue Quelle ins Compiler-Ergebnis einfügen
		context.AddSource("GeneratedOllamaTools.g.cs", sb.ToString());
	}

	/// <summary>
	/// Unser SyntaxReceiver sucht nur nach Methoden, die das [OllamaTool]-Attribut tragen.
	/// </summary>
	private class SyntaxReceiver : ISyntaxReceiver
	{
		public List<MethodDeclarationSyntax> CandidateMethods { get; } = new();

		public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
		{
			// Nur bei MethodDeclarationSyntax weitermachen
			if (syntaxNode is MethodDeclarationSyntax methodDecl)
			{
				// Prüfen, ob die Methode das [OllamaTool] Attribut hat
				// (Name kann "OllamaTool" oder "OllamaToolAttribute" lauten)
				var hasOllamaToolAttribute = methodDecl.AttributeLists
					.SelectMany(attrList => attrList.Attributes)
					.Any(a =>
					{
						var nameStr = a.Name.ToString();
						return nameStr == "OllamaTool" || nameStr == "OllamaToolAttribute";
					});

				if (hasOllamaToolAttribute)
				{
					CandidateMethods.Add(methodDecl);
				}
			}
		}
	}

	// ------------------------------------------------------
	// Hilfsmethoden (wie in deinem bisherigen Code)

	private static string GetSummaryFromDocs(string docXml)
	{
		if (string.IsNullOrEmpty(docXml))
			return string.Empty;

		const string summaryStart = "<summary>";
		const string summaryEnd = "</summary>";

		int startIndex = docXml.IndexOf(summaryStart);
		int endIndex = docXml.IndexOf(summaryEnd);
		if (startIndex == -1 || endIndex == -1)
			return string.Empty;

		string inner = docXml.Substring(startIndex + summaryStart.Length, endIndex - (startIndex + summaryStart.Length));
		return inner.Trim();
	}

	private static string BuildParametersJson(IMethodSymbol methodSymbol)
	{
		var sb = new StringBuilder();
		bool firstParam = true;

		foreach (var parameter in methodSymbol.Parameters)
		{
			if (!firstParam)
				sb.Append(", ");

			string paramName = parameter.Name;
			string paramDoc = GetParamDoc(methodSymbol.GetDocumentationCommentXml(), paramName);
			string paramDocEscaped = EscapeForJson(paramDoc);

			if (parameter.Type.TypeKind == TypeKind.Enum)
			{
				// Alle Enum-Felder
				if (parameter.Type is INamedTypeSymbol enumType && enumType.TypeKind == TypeKind.Enum)
				{
					var enumValues = enumType.GetMembers()
						.OfType<IFieldSymbol>()
						.Where(f => !f.IsImplicitlyDeclared)
						.Select(f => $"\"{f.Name}\"");

					string enumJson = string.Join(", ", enumValues);
					sb.Append($"\"{paramName}\": {{ \"type\": \"string\", \"description\": \"{paramDocEscaped}\", \"enum\": [{enumJson}] }}");
				}
				else
				{
					sb.Append($"\"{paramName}\": {{ \"type\": \"string\", \"description\": \"{paramDocEscaped}\" }}");
				}
			}
			else
			{
				sb.Append($"\"{paramName}\": {{ \"type\": \"string\", \"description\": \"{paramDocEscaped}\" }}");
			}

			firstParam = false;
		}

		return sb.ToString();
	}

	private static string GetParamDoc(string docXml, string paramName)
	{
		if (string.IsNullOrEmpty(docXml))
			return string.Empty;

		string searchFor = $"name=\"{paramName}\"";
		int paramIndex = docXml.IndexOf(searchFor);
		if (paramIndex == -1)
			return string.Empty;

		int start = docXml.IndexOf('>', paramIndex);
		int end = docXml.IndexOf("</param>", start);
		if (start == -1 || end == -1)
			return string.Empty;

		string content = docXml.Substring(start + 1, end - (start + 1));
		return content.Trim();
	}

	private static string EscapeForJson(string value)
	{
		if (string.IsNullOrEmpty(value))
			return value ?? string.Empty;

		return value
			.Replace("\\", "\\\\")
			.Replace("\"", "\\\"");
	}
}

//// Extension-Klasse, um im Execute() auf IMethodSymbol zuzugreifen
//// (Sinnvoll: an passender Stelle in Execute() "fixen")
//public static class GeneratorExtensions
//{
//	public static void FixCandidateMethods(this OllamaToolGenerator.SyntaxReceiver receiver, Compilation compilation)
//	{
//		for (int i = 0; i < receiver.CandidateMethods.Count; i++)
//		{
//			// Falls wir den Placeholder null! gesetzt hatten, hier „reparieren“:
//			// Nicht in diesem Minimal-Beispiel gezeigt,
//			// weil wir das Symbolmatching gleich direkt beim Visit machen könnten.
//		}
//	}
//}